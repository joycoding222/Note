# 字节面试准备

> 整理了从网上找到的字节客户端面经

1. C++多态是如何实现的：

   多态主要通过**虚函数**和**动态绑定**实现。
   基类定义虚方法，派生类通过重写基类的虚方法，通过基类指针/引用调用虚方法时发生多态

   > 静态绑定：编译器决定调用哪个函数
   >
   > 动态绑定：运行时决定调用哪个函数。程序将基于实际对象的指针或引用的类型选择方法，而不是基于指针或引用的类型。
   >
   > 虚函数原理：
   >
   > - 编译器为每个包含虚函数的类生成一个虚函数表，虚函数表是一个函数指针数组，存储该类所有虚函数的地址，当派生类重写虚函数，虚函数表中对应位置个更新为派生类的函数地址
   > - 每个对象创建时内部有一个虚指针，指向虚函数表

2. C++ 中 const 的作用是什么：
   const常量：声明不可修改的值；保护函数参数防止意外修改；
   const函数：不修改变量的值
   const成员变量：和const变量一样
   const成员函数：不修改成员变量的值

   类的内部包含const成员，编译器删除默认的拷贝赋值运算符
   const还可以区分函数重载

   **const是不是可以修饰一个引用？**
   可以修饰临时对象的左值引用，延长临时对象的生命周期

   ```cpp
   int a = 10;
   int &b = 10;	// Error!!! 非常量引用不能绑定右值，其初始值必须为左值
   const int &b = 10;	// OKAY
   ```

3. static
   `static`关键字主要控制变量和函数的声明周期、作用域和链接属性。

   用法：

   1. 静态局部变量

   ```cpp
   void counter() {
       static int count = 0; // 静态局部变量
       count++;
       cout << "Count: " << count << endl;
   }
   
   int main() {
       counter(); // 输出 Count: 1
       counter(); // 输出 Count: 2
       counter(); // 输出 Count: 3
   }
   
   /*
   特点：
   生命周期：整个程序运行期间
   作用域：仅限于函数内部
   初始化：首次进入函数时，初始化一次
   内存位置：
   数据段
   */
   ```

   2. 静态成员变量（类内部）：

   ```cpp
   class Player {
   public:
       static int totalPlayers; // 声明静态成员变量
       
       Player() { totalPlayers++; }
       ~Player() { totalPlayers--; }
   };
   
   int Player::totalPlayers = 0; // 类外定义（必需！）
   
   int main() {
       Player p1;
       Player p2;
       cout << Player::totalPlayers; // 输出 2
   }
   
   /*
   特点：
   1. 类的所有实例共享同一副本
   初始化：
   2. 必须在类的外部单独初始化！！！！！
   */
   ```

   3. 静态成员函数（类内部）

   ```cpp
   class MathUtils {
   public:
       static int add(int a, int b) {
           return a + b;
       }
       
       // 错误：静态函数不能访问非静态成员
       // static void error() { cout << value; } 
   private:
       int value;
   };
   
   int main() {
       int sum = MathUtils::add(5, 3); // 无需实例化
   }
   
   /*
   特点：
   1. 无this指针：静态成员函数不能访问非静态成员；
   2. 可以通过类名直接调用
   */
   ```

4. C++11特性：

5. auto:

      自动类型推导，让编译器根据初始化表达式自动推断变量的类型。它是现代 C++（C++11 及更高版本）的核心特性之一。

      使用场景：

      - 容器迭代器
      - 复杂类型
      - lambda表达式
      - 模板编程

      关键规则：

      - 必须初始化

6. 定义一个空的class，系统默认的实现：

   构造、析构、拷贝构造、赋值运算符重载

   ```cpp
   class Empty{};
   
   // 默认生成：
   Empty();	// 默认构造函数
   ~Empty();	// 默认析构函数
   Empty(const Empty&);	// 默认拷贝构造
   Empty& operator=(const Empty&);	// 拷贝赋值运算符重载
   Empty(Empty&&);	// 移动构造函数(C++11)
   Empty& operator=(Empty&&);	// 移动赋值运算符(C++11)
   ```

7. move操作

      移动操作是 C++11 引入的核心特性，它允许**高效转移资源所有权**而非复制资源，显著提升程序性能。

      ```cpp
      // std::move 强制转换为右值
      std::vector<std::string> vec;
      std::string str = "hello";
      vec.push_back(std::move(str));	// 移动资源而非拷贝
      ```

      

8. 不想让系统生成这么多默认函数如何处理：
      手动定义或者delete

9. C++高并发场景如何保证线程同步

10. C++锁

11. 互斥锁底层原理

12. 读写锁的实现

13. 线程同步的方法

          线程同步：
          线程互斥：mutex（互斥锁） atomic(简单操作适用，基于CAS操作)
          线程通信：条件变量condition_variable + 信号量semaphore

14. 对于简单的加法，为什么C++效率比python高

15. C++一段代码的编译过程

          - 预处理：输入`.cpp` 输出`.i`：插入头文件`#include`，替换宏`define`，条件编译`ifdef`，注释删除
          - 编译：输入.i 输出.s （汇编文件）：
          - 汇编：输入.s 输出.o（将汇编文件转成机器码目标文件）
          - 链接：输入.o 输出.exe（链接多个目标文件成可执行文件）

          > 简单可以说：
          >
          > 1. source code(.c) --(Compile)--> object file (.o)（二进制目标文件）
          > 2. object file(.o) --(Link)--> executable file

16. 加法减法谁的效率高？计算机底层如何实现减法

17. 堆栈的区别：
          堆用于动态内存申请，栈用于临时变量

18. `int a[10]`内存如何分配？堆还是栈？

19. 在函数中定义的数组，离开函数时空间会释放吗？如何释放？

20. 像vector这样的可变数组，是在堆上还是栈上？它在函数中定义，离开函数时如何释放？

21. 数组和链表有什么区别？它们的查找效率呢？

22. 内联函数和宏函数的区别：

       - 宏函数在预处理阶段进行文本替换，无类型检查易出错，不参与编译调试困难

       - 内联函数在编译时展开代码，有类型检查和作用域规则，可调试，适用于小函数

       - 补充：

         Q: 内联函数一定展开吗

         A: 不一定，由编译器决定，`inline`关键字只是建议编译器进行展开

23. Q: 为什么内联函数会减少调用开销

       A: 使用内联函数消除函数调用成本：无栈帧创建或销毁，无参数压栈出栈，无返回地址保存

24. Q: 编译器如何优化内联函数

       A: 将函数体复制到调用点，进行上下文优化移除未使用的代码，小循环直接展开，优先使用寄存器存储局部变量

25. Q: 引用和指针的区别

       A: 

       区别：

       - 引用必须初始化，指针可以后续再初始化；
       - 引用不能为空值，指针可以；
       - 引用不能改变引用目标，指针可以改变指向；(对引用的操作与对变量直接操作完全一样)
       - 引用通常不占用额外空间，指针占用
       - 引用没有多级引用，指针可以有多级指针

       相同点：

       - 底层引用和指针的实现一致

```cpp
#include <iostream>

using namespace std;

int main()
{
    int a = 10, b = 13;
    int &c = a;
    cout << "a = " << a << endl;    // 10
    cout << "b = " << b << endl;    // 13
    cout << "c = " << c << endl;    // 10

    c = b;  // 期望中下面应该输出：10 13 13，但实际上不是，说明c仍然是a的别名
    cout << "a = " << a << endl;    // 13
    cout << "b = " << b << endl;    // 13
    cout << "c = " << c << endl;    // 13

    return 0;
}
```

26. Q: 堆栈的区别

    A: 

    - 栈内存由编译器自动管理，堆内存由程序员手动管理；
    - 栈的分配速度块，堆的分配速度慢；
    - 变量生命周期不一样，栈上的变量在函数结束后自动释放，堆变量需要由程序员手动管理；
    - 栈无内存碎片，堆有

27. Q: 为什么栈内存访问块

    A: 栈内存连续分配，CPU缓存命中率高；堆内存分配需要系统调用；每个线程独立栈空间无需竞争；

28. Q: `#pragma once`和`ifndef`的区别：
    A: 前者是编译器专属速度更快，后者是跨平台

29. 虚拟内存:

    操作系统系统的抽象层，使每个进程拥有独立的连续私有地址空间，通过页表映射到物理内存

    为什么需要虚拟内存：

    - 内存隔离：进程无法直接访问物理内存
    - 简化编程：连续虚拟地址空间
    - 内存超额使用：交换空间（Swap）支持大于物理内存的程序
    - 共享内存：多个进程共享库代码（如 libc.so）

    为什么内存安全性高：

    1. **权限控制**：页表设置 R/W/X 权限位
       - 代码段只读可执行
       - 数据段可读写不可执行
    2. **隔离保护**：
       - 用户态无法访问内核空间
       - 进程无法访问其他进程内存
    3. **地址随机化（ASLR）**：
       随机布局内存区域，防止缓冲区溢出攻击

30. Q: 进程和线程的关系

    A: 进程是资源分配的基本单位，而线程是操作系统调度的基本单位，并且共享线程资源；

31. 分页机制：
    将虚拟/物理内存划分为固定大小页（通常4KB），通过页表映射。

    **目的**：

    1. 解决内存碎片问题
    2. 支持虚拟内存（页可换出到磁盘）
    3. 细粒度权限控制（以页为单位设置权限）

32. Q: 线程共享内存的问题

    A: 多线程访问临界区资源导致结果不确定；死锁问题；

33. 常见的锁：

    互斥锁：阻塞等待

    自旋锁：忙等待（原地自旋）

    读写锁：区分读写操作

    条件变量：事件驱动

    互斥锁VS自旋锁：线程未抢占到互斥锁阻塞等待出让时间片，未抢占到自旋锁忙循环消耗CPU，不出让时间片；互斥锁适用于临界区长时间操作，自旋锁适用于短时间访问临界区，锁竞争不激烈；互斥锁通过系统调用实现，自旋锁通过CAS操作实现

34. 视频通话选用UDP：视频通话的实时性需求大于可靠性需求

    文字传输选用TCP：可靠性需求大于实时性需求



## 手撕

1. 判断对称二叉树
2. C++单例模式
3. 无重复字符的最长字串

