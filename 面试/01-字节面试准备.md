# 字节面试准备

> 整理了从网上找到的字节客户端面经

1. C++多态是如何实现的：

   多态主要通过**虚函数**和**动态绑定**实现。
   基类定义虚方法，派生类通过重写基类的虚方法，通过基类指针/引用调用虚方法时发生多态

   > 静态绑定：编译器决定调用哪个函数
   >
   > 动态绑定：运行时决定调用哪个函数。程序将基于实际对象的指针或引用的类型选择方法，而不是基于指针或引用的类型。
   >
   > 虚函数原理：
   >
   > - 编译器为每个包含虚函数的类生成一个虚函数表，虚函数表是一个函数指针数组，存储该类所有虚函数的地址，当派生类重写虚函数，虚函数表中对应位置个更新为派生类的函数地址
   > - 每个对象创建时内部有一个虚指针，指向虚函数表

2. C++ 中 const 的作用是什么：
   const常量：声明不可修改的值；保护函数参数防止意外修改；
   const函数：不修改变量的值
   const成员变量：和const变量一样
   const成员函数：不修改成员变量的值

   类的内部包含const成员，编译器删除默认的拷贝赋值运算符
   const还可以区分函数重载

   **const是不是可以修饰一个引用？**
   可以修饰临时对象的左值引用，延长临时对象的生命周期

   ```cpp
   int a = 10;
   int &b = 10;	// Error!!! 非常量引用不能绑定右值，其初始值必须为左值
   const int &b = 10;	// OKAY
   ```

3. static
   `static`关键字主要控制变量和函数的声明周期、作用域和链接属性。

   用法：

   1. 静态局部变量

   ```cpp
   void counter() {
       static int count = 0; // 静态局部变量
       count++;
       cout << "Count: " << count << endl;
   }
   
   int main() {
       counter(); // 输出 Count: 1
       counter(); // 输出 Count: 2
       counter(); // 输出 Count: 3
   }
   
   /*
   特点：
   生命周期：整个程序运行期间
   作用域：仅限于函数内部
   初始化：首次进入函数时，初始化一次
   内存位置：
   数据段
   */
   ```

   2. 静态成员变量（类内部）：

   ```cpp
   class Player {
   public:
       static int totalPlayers; // 声明静态成员变量
       
       Player() { totalPlayers++; }
       ~Player() { totalPlayers--; }
   };
   
   int Player::totalPlayers = 0; // 类外定义（必需！）
   
   int main() {
       Player p1;
       Player p2;
       cout << Player::totalPlayers; // 输出 2
   }
   
   /*
   特点：
   1. 类的所有实例共享同一副本
   初始化：
   2. 必须在类的外部单独初始化！！！！！
   */
   ```

   3. 静态成员函数（类内部）

   ```cpp
   class MathUtils {
   public:
       static int add(int a, int b) {
           return a + b;
       }
       
       // 错误：静态函数不能访问非静态成员
       // static void error() { cout << value; } 
   private:
       int value;
   };
   
   int main() {
       int sum = MathUtils::add(5, 3); // 无需实例化
   }
   
   /*
   特点：
   1. 无this指针：静态成员函数不能访问非静态成员；
   2. 可以通过类名直接调用
   */
   ```

4. C++11特性：

5. auto:

      自动类型推导，让编译器根据初始化表达式自动推断变量的类型。它是现代 C++（C++11 及更高版本）的核心特性之一。

      使用场景：

      - 容器迭代器
      - 复杂类型
      - lambda表达式
      - 模板编程

      关键规则：

      - 必须初始化

6. 定义一个空的class，系统默认的实现：

   构造、析构、拷贝构造、赋值运算符重载

   ```cpp
   class Empty{};
   
   // 默认生成：
   Empty();	// 默认构造函数
   ~Empty();	// 默认析构函数
   Empty(const Empty&);	// 默认拷贝构造
   Empty& operator=(const Empty&);	// 拷贝赋值运算符重载
   Empty(Empty&&);	// 移动构造函数(C++11)
   Empty& operator=(Empty&&);	// 移动赋值运算符(C++11)
   ```

7. move操作

      移动操作是 C++11 引入的核心特性，它允许**高效转移资源所有权**而非复制资源，显著提升程序性能。

      ```cpp
      // std::move 强制转换为右值
      std::vector<std::string> vec;
      std::string str = "hello";
      vec.push_back(std::move(str));	// 移动资源而非拷贝
      ```

      

8. 不想让系统生成这么多默认函数如何处理：
      手动定义或者delete

9. C++高并发场景如何保证线程同步

10. C++锁

11. 互斥锁底层原理

12. 读写锁的实现

13. 线程同步的方法

       线程同步：
       线程互斥：mutex（互斥锁） atomic(简单操作适用，基于CAS操作)
       线程通信：条件变量condition_variable + 信号量semaphore

14. 对于简单的加法，为什么C++效率比python高

15. C++一段代码的编译过程

       - 预处理：输入.cpp 输出.i：插入头文件，替换宏，条件编译，注释删除
       - 编译：输入.i 输出.s ：
       - 汇编：输入.s 输出.o
       - 链接：输入.o 输出.exe（可执行文件）

       > 简单可以说：
       >
       > 1. source code(.c) --(Compile)--> object file (.o)（二进制目标文件）
       > 2. object file(.o) --(Link)--> executable file

16. 加法减法谁的效率高？计算机底层如何实现减法

17. 堆栈的区别：
       堆用于动态内存申请，栈用于临时变量

18. `int a[10]`内存如何分配？堆还是栈？

19. 在函数中定义的数组，离开函数时空间会释放吗？如何释放？

20. 像vector这样的可变数组，是在堆上还是栈上？它在函数中定义，离开函数时如何释放？

21. 数组和链表有什么区别？它们的查找效率呢？



## 手撕

1. 判断对称二叉树
2. C++单例模式
3. 无重复字符的最长字串

